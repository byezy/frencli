//! Rename subcommand for actually performing file renames.
//! 
//! This module handles the `fren rename` command which performs the actual file renaming
//! operations based on a preview generated by the transform command. All operations are async.

use freneng::{perform_renames, FrenError, EnginePreviewResult, FileRename, log_audit_from_result};
use freneng::history::save_history;
use crate::ui::interactive_edit;
use std::io::{self, Write};
use std::env;
use std::path::PathBuf;

/// Handles the rename subcommand - actually performs the rename using the preview result.
/// 
/// # Arguments
/// 
/// * `preview_result` - The preview result from the transform command (contains the mapping)
/// * `overwrite` - Whether to overwrite existing files
/// * `yes` - Skip confirmation prompt (rename all)
/// * `interactive` - Interactive mode (edit filenames individually)
/// * `command` - Full command line for audit logging
/// * `pattern` - Pattern used for audit logging
/// * `enable_audit` - Whether to log to audit file (default: true)
/// 
/// # Returns
/// 
/// * `Ok(())` - Command completed successfully
/// * `Err(FrenError)` - If renaming fails
pub async fn handle_rename_command(
    preview_result: EnginePreviewResult,
    overwrite: bool,
    yes: bool,
    interactive: bool,
    command: String,
    pattern: Option<String>,
    enable_audit: bool,
) -> Result<(), FrenError> {
    // Preview was already shown by transform/template --use, so we don't show it again

    // Show warnings
    if !preview_result.warnings.is_empty() {
        println!("\nWARNINGS:");
        for warning in &preview_result.warnings {
            println!("  - {}", warning);
        }
    }

    // Block if empty names
    if preview_result.has_empty_names {
        eprintln!("\nERROR: One or more files would have an empty name. Renaming aborted.");
        eprintln!("Please check your pattern and ensure it generates valid filenames.");
        std::process::exit(1);
    }

    let mut renames = preview_result.renames;

    // Interactive mode: edit filenames individually
    if interactive {
        if !interactive_edit(&mut renames) {
            println!("Interactive editing cancelled.");
            return Ok(());
        }

        // Re-validate after interactive editing
        let has_empty = renames.iter().any(|r| r.new_name.trim().is_empty());
        if has_empty {
            eprintln!("\nERROR: One or more files would have an empty name. Renaming aborted.");
            eprintln!("Please check your pattern and ensure it generates valid filenames.");
            std::process::exit(1);
        }
    }

    // If not --yes and not --interactive, prompt for each file
    if !yes && !interactive {
        renames = prompt_each_rename(&renames)?;
        if renames.is_empty() {
            println!("No files to rename.");
            return Ok(());
        }
    }

    // Apply renames
    match perform_renames(&renames, overwrite).await {
        Ok(execution) => {
            // Report results
            if !execution.skipped.is_empty() {
                for (path, reason) in &execution.skipped {
                    println!("Skipping {}: {}", path.display(), reason);
                }
            }
            
            if !execution.errors.is_empty() {
                eprintln!("\nErrors:");
                for (path, err) in &execution.errors {
                    eprintln!("  {}: {}", path.display(), err);
                }
            }
            
            println!("\nSuccessfully renamed {} file(s).", execution.successful.len());
            
            // Save history
            if let Err(e) = save_history(execution.successful.clone()).await {
                eprintln!("Warning: Failed to save rename history: {}", e);
            }
            
            // Log to audit file (if enabled)
            if enable_audit {
                let working_dir = env::current_dir().unwrap_or_else(|_| PathBuf::from("."));
                
                if let Err(e) = log_audit_from_result(
                    &command,
                    pattern,
                    working_dir,
                    &execution,
                ).await {
                    eprintln!("Warning: Failed to write audit log: {}", e);
                }
            }
            
            Ok(())
        }
        Err(e) => {
            eprintln!("Error performing renames: {}", e);
            Err(e)
        }
    }
}

/// Prompts the user for each rename operation.
/// 
/// Returns a filtered list of renames to apply based on user choices.
fn prompt_each_rename(renames: &[FileRename]) -> Result<Vec<FileRename>, FrenError> {
    println!("\nConfirm each rename (y=yes, s=skip, a=apply all remaining, q=abort):");
    println!("{:-<80}", "");
    
    let mut to_apply = Vec::new();
    let mut apply_all = false;
    
    for (i, rename) in renames.iter().enumerate() {
        if apply_all {
            to_apply.push(rename.clone());
            continue;
        }
        
        let old = rename.old_path.file_name().and_then(|n| n.to_str()).unwrap_or("?");
        let new = &rename.new_name;
        
        loop {
            print!("\n[{}] {} -> {} (y/s/a/q): ", i + 1, old, new);
            io::stdout().flush().map_err(|e| FrenError::Pattern(format!("IO error: {}", e)))?;
            
            let mut input = String::new();
            io::stdin().read_line(&mut input).map_err(|e| FrenError::Pattern(format!("IO error: {}", e)))?;
            let input = input.trim().to_lowercase();
            
            match input.as_str() {
                "y" | "yes" => {
                    to_apply.push(rename.clone());
                    break;
                }
                "s" | "skip" => {
                    // Skip this file
                    break;
                }
                "a" | "all" => {
                    // Apply all remaining
                    to_apply.push(rename.clone());
                    apply_all = true;
                    break;
                }
                "q" | "quit" | "abort" => {
                    println!("Aborted.");
                    return Ok(Vec::new());
                }
                _ => {
                    println!("Invalid choice. Use: y (yes), s (skip), a (all), q (abort)");
                    continue;
                }
            }
        }
    }
    
    Ok(to_apply)
}

