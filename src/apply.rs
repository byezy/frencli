//! Apply subcommand for actually performing file renames.
//! 
//! This module handles the `frencli apply` command which performs the actual file renaming
//! operations based on a preview generated by the rename command. All operations are async.

use freneng::{perform_renames, FrenError, EnginePreviewResult, FileRename, log_audit_from_result};
use freneng::history::save_history;
use crate::ui::interactive_edit;
use std::io::{self, Write};
use std::env;
use std::path::PathBuf;
use serde::Serialize;

#[derive(Serialize)]
struct ApplyJsonOutput {
    successful: Vec<ApplyJsonItem>,
    skipped: Vec<SkippedJsonItem>,
    errors: Vec<ErrorJsonItem>,
    count: usize,
}

#[derive(Serialize)]
struct ApplyJsonItem {
    old_path: String,
    new_path: String,
    new_name: String,
}

#[derive(Serialize)]
struct SkippedJsonItem {
    path: String,
    reason: String,
}

#[derive(Serialize)]
struct ErrorJsonItem {
    path: String,
    error: String,
}

/// Handles the apply subcommand - actually performs the rename using the preview result.
/// 
/// # Arguments
/// 
/// * `preview_result` - The preview result from the rename command (contains the mapping)
/// * `overwrite` - Whether to overwrite existing files
/// * `yes` - Skip confirmation prompt (rename all)
/// * `interactive` - Interactive mode (edit filenames individually)
/// * `command` - Full command line for audit logging
/// * `pattern` - Pattern used for audit logging
/// * `enable_audit` - Whether to log to audit file (default: true)
/// * `json` - If true, output as JSON; if false, output as human-readable
/// 
/// # Returns
/// 
/// * `Ok(())` - Command completed successfully
/// * `Err(FrenError)` - If renaming fails
pub async fn handle_apply_command(
    preview_result: EnginePreviewResult,
    overwrite: bool,
    yes: bool,
    interactive: bool,
    command: String,
    pattern: Option<String>,
    enable_audit: bool,
    json: bool,
) -> Result<(), FrenError> {
    // Preview was already shown by rename/template --use, so we don't show it again

    // Show warnings
    if !preview_result.warnings.is_empty() {
        println!("\nWARNINGS:");
        for warning in &preview_result.warnings {
            println!("  - {}", warning);
        }
    }

    // Block if empty names
    if preview_result.has_empty_names {
        eprintln!("\nERROR: One or more files would have an empty name. Renaming aborted.");
        eprintln!("Please check your pattern and ensure it generates valid filenames.");
        std::process::exit(1);
    }

    let mut renames = preview_result.renames;

    // Interactive mode: edit filenames individually
    if interactive {
        if !interactive_edit(&mut renames) {
            println!("Interactive editing cancelled.");
            return Ok(());
        }

        // Re-validate after interactive editing
        let has_empty = renames.iter().any(|r| r.new_name.trim().is_empty());
        if has_empty {
            eprintln!("\nERROR: One or more files would have an empty name. Renaming aborted.");
            eprintln!("Please check your pattern and ensure it generates valid filenames.");
            std::process::exit(1);
        }
    }

    // If not --yes and not --interactive, prompt for each file
    if !yes && !interactive {
        renames = prompt_each_rename(&renames)?;
        if renames.is_empty() {
            println!("No files to rename.");
            return Ok(());
        }
    }

    // Apply renames
    match perform_renames(&renames, overwrite).await {
        Ok(execution) => {
            if json {
                // Output as JSON
                let json_output = ApplyJsonOutput {
                    successful: execution.successful.iter().map(|action| ApplyJsonItem {
                        old_path: action.old_path.to_string_lossy().to_string(),
                        new_path: action.new_path.to_string_lossy().to_string(),
                        new_name: action.new_path.file_name()
                            .and_then(|n| n.to_str())
                            .map(|s| s.to_string())
                            .unwrap_or_else(|| "?".to_string()),
                    }).collect(),
                    skipped: execution.skipped.iter().map(|(path, reason)| SkippedJsonItem {
                        path: path.to_string_lossy().to_string(),
                        reason: reason.clone(),
                    }).collect(),
                    errors: execution.errors.iter().map(|(path, err)| ErrorJsonItem {
                        path: path.to_string_lossy().to_string(),
                        error: err.clone(),
                    }).collect(),
                    count: execution.successful.len(),
                };
                let json_str = serde_json::to_string_pretty(&json_output)
                    .map_err(|e| FrenError::Pattern(format!("Failed to serialize JSON: {}", e)))?;
                println!("{}", json_str);
            } else {
                // Report results
                if !execution.skipped.is_empty() {
                    for (path, reason) in &execution.skipped {
                        println!("Skipping {}: {}", path.display(), reason);
                    }
                }
                
                if !execution.errors.is_empty() {
                    eprintln!("\nErrors:");
                    for (path, err) in &execution.errors {
                        eprintln!("  {}: {}", path.display(), err);
                    }
                }
                
                println!("\nSuccessfully renamed {} file(s).", execution.successful.len());
            }
            
            // Save history
            if let Err(e) = save_history(execution.successful.clone()).await {
                if !json {
                    eprintln!("Warning: Failed to save rename history: {}", e);
                }
            }
            
            // Log to audit file (if enabled)
            if enable_audit {
                let working_dir = env::current_dir().unwrap_or_else(|_| PathBuf::from("."));
                
                if let Err(e) = log_audit_from_result(
                    &command,
                    pattern,
                    working_dir,
                    &execution,
                ).await {
                    if !json {
                        eprintln!("Warning: Failed to write audit log: {}", e);
                    }
                }
            }
            
            Ok(())
        }
        Err(e) => {
            if json {
                let error_json = serde_json::json!({
                    "error": e.to_string(),
                    "successful": [],
                    "skipped": [],
                    "errors": [],
                    "count": 0
                });
                println!("{}", serde_json::to_string_pretty(&error_json).unwrap());
            } else {
                eprintln!("Error performing renames: {}", e);
            }
            Err(e)
        }
    }
}

/// Prompts the user for each rename operation.
/// 
/// Returns a filtered list of renames to apply based on user choices.
fn prompt_each_rename(renames: &[FileRename]) -> Result<Vec<FileRename>, FrenError> {
    println!("\nConfirm each rename (y=yes, s=skip, a=apply all remaining, q=abort):");
    println!("{:-<80}", "");
    
    let mut to_apply = Vec::new();
    let mut apply_all = false;
    
    for (i, rename) in renames.iter().enumerate() {
        if apply_all {
            to_apply.push(rename.clone());
            continue;
        }
        
        let old = rename.old_path.file_name().and_then(|n| n.to_str()).unwrap_or("?");
        let new = &rename.new_name;
        
        loop {
            print!("\n[{}] {} -> {} (y/s/a/q): ", i + 1, old, new);
            io::stdout().flush().map_err(|e| FrenError::Pattern(format!("IO error: {}", e)))?;
            
            let mut input = String::new();
            io::stdin().read_line(&mut input).map_err(|e| FrenError::Pattern(format!("IO error: {}", e)))?;
            let input = input.trim().to_lowercase();
            
            match input.as_str() {
                "y" | "yes" => {
                    to_apply.push(rename.clone());
                    break;
                }
                "s" | "skip" => {
                    // Skip this file
                    break;
                }
                "a" | "all" => {
                    // Apply all remaining
                    to_apply.push(rename.clone());
                    apply_all = true;
                    break;
                }
                "q" | "quit" | "abort" => {
                    println!("Aborted.");
                    return Ok(Vec::new());
                }
                _ => {
                    println!("Invalid choice. Use: y (yes), s (skip), a (all), q (abort)");
                    continue;
                }
            }
        }
    }
    
    Ok(to_apply)
}

